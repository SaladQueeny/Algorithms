# Algorithms

### The problem of linear cutting and greedy algorithm

The problem of linear cutting and greedy algorithm on the example of the optimal separation of the rod you can see in ProbleOfLinearCuttingAndGreedyAlgorithm.pdf. Code of this c++ solution you can see in ProbleOfLinearCuttingAndGreedyAlgorithm.pdf

## Sorts

### Bubble sort

Пример есть в sorts++.txt

complexity - O(n^2)
Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется перестановка элементов. Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на своё место в конце массива рядом с предыдущим «наибольшим элементом», а наименьший элемент перемещается на одну позицию к началу массива.

![huj_u2r8s_xio_nupbtsqx1vgte](https://user-images.githubusercontent.com/70723969/133135622-f58e2c65-abfe-486d-a291-ccdca65cfc19.gif)

### Selection sort

Пример есть в sorts++.txt

complexity - O(n^2)
Алгоритм:
1. Находим номер минимального значения в текущем списке
2. Производим обмен этого значения со значением первой неотсортированной позиции (обмен не нужен, если минимальный элемент уже находится на данной позиции)
3. Теперь сортируем хвост списка, исключив из рассмотрения уже отсортированные элементы

![Selection-Sort-Animation](https://user-images.githubusercontent.com/70723969/133135537-79863f04-bc01-4e2d-b8ec-81ac1448a35c.gif)

### Insert sort

Пример есть в sorts++.txt

complexity - O(n^2)
Простой алгоритм сортировки, при которой очередной элемент добавляется всегда в конец списка, а затем перемещается в начало списка до тех пор, пока он меньше предыдущего элемента. Таким образом, формально, находится правильное место для вставки.

![274px-Insertion-sort-example-300px](https://user-images.githubusercontent.com/70723969/133135503-7b882cb1-cf8d-46d7-ad64-9c196819d789.gif)

### Shell sort

Пример есть в sorts++.txt

complexity - the worst O(n^2), the best - O(n log^2 n).
При сортировке Шелла сначала сравниваются и сортируются между собой значения, стоящие один от другого на некотором расстоянии d(array.size()/2) . После этого процедура повторяется для некоторых меньших значений d(d/=2), а завершается сортировка Шелла упорядочиванием элементов при d=1 (то есть обычной сортировкой вставками). Эффективность сортировки Шелла в определённых случаях обеспечивается тем, что элементы «быстрее» встают на свои места (в простых методах сортировки, например, пузырьковой, каждая перестановка двух элементов уменьшает количество инверсий в списке максимум на 1, а при сортировке Шелла это число может быть больше).

Невзирая на то, что сортировка Шелла во многих случаях медленнее, чем быстрая сортировка, она имеет ряд преимуществ:
1. Отсутствие потребности в памяти под стек;
2. Отсутствие деградации при неудачных наборах данных — быстрая сортировка легко деградирует до O(n²), что хуже, чем худшее гарантированное время для сортировки Шелла.

Пример сортировки с шагами 23 10 4 1:

![Sorting_shellsort_anim](https://user-images.githubusercontent.com/70723969/133135401-95dcab76-e073-43c3-a6b8-cf7c220e90bb.gif)

### Quick sort

Пример есть в sorts++.txt

complexity - the worst O(n^2), the best - O(n log^2 n).

Общая идея алгоритма состоит в следующем:
1. Выбрать из массива элемент, называемый опорным. Это может быть любой из элементов массива. От выбора опорного элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность
2. Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на две части: «меньшие опорного» и «равные и большие»
3. Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.

Быстрая сортировка относится к алгоритмам «разделяй и властвуй».

![274px-Sorting_quicksort_anim](https://user-images.githubusercontent.com/70723969/133135274-9ad30da3-cb5a-4a0e-a52a-c8e1dc646b97.gif)

### Merge sort

Пример есть в MergeSort.java

complexity - O(n log n)

Для решения задачи сортировки эти три этапа выглядят так:
1. Сортируемый массив разбивается на две части примерно одинакового размера;
2. Каждая из получившихся частей сортируется отдельно;
3. Два упорядоченных массива половинного размера соединяются в один.

![274px-Merge-sort-example-300px](https://user-images.githubusercontent.com/70723969/133136056-9358c210-a7eb-4643-909c-393d1f9f3c6e.gif)
